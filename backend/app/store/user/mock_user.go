// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package user

import (
	"github.com/yaattc/automatic-time-table-creation/backend/app/store"
	"sync"
)

// Ensure, that InterfaceMock does implement Interface.
// If this is not the case, regenerate this file with moq.
var _ Interface = &InterfaceMock{}

// InterfaceMock is a mock implementation of Interface.
//
//     func TestSomethingThatUsesInterface(t *testing.T) {
//
//         // make and configure a mocked Interface
//         mockedInterface := &InterfaceMock{
//             AddUserFunc: func(user store.User, pwd string, ignoreIfExists bool) (string, error) {
// 	               panic("mock out the AddUser method")
//             },
//             GetPasswordHashFunc: func(email string) (string, error) {
// 	               panic("mock out the GetPasswordHash method")
//             },
//             GetUserFunc: func(id string) (store.User, error) {
// 	               panic("mock out the GetUser method")
//             },
//         }
//
//         // use mockedInterface in code that requires Interface
//         // and then make assertions.
//
//     }
type InterfaceMock struct {
	// AddUserFunc mocks the AddUser method.
	AddUserFunc func(user store.User, pwd string, ignoreIfExists bool) (string, error)

	// GetPasswordHashFunc mocks the GetPasswordHash method.
	GetPasswordHashFunc func(email string) (string, error)

	// GetUserFunc mocks the GetUser method.
	GetUserFunc func(id string) (store.User, error)

	// calls tracks calls to the methods.
	calls struct {
		// AddUser holds details about calls to the AddUser method.
		AddUser []struct {
			// User is the user argument value.
			User store.User
			// Pwd is the pwd argument value.
			Pwd string
			// IgnoreIfExists is the ignoreIfExists argument value.
			IgnoreIfExists bool
		}
		// GetPasswordHash holds details about calls to the GetPasswordHash method.
		GetPasswordHash []struct {
			// Email is the email argument value.
			Email string
		}
		// GetUser holds details about calls to the GetUser method.
		GetUser []struct {
			// ID is the id argument value.
			ID string
		}
	}
	lockAddUser         sync.RWMutex
	lockGetPasswordHash sync.RWMutex
	lockGetUser         sync.RWMutex
}

// AddUser calls AddUserFunc.
func (mock *InterfaceMock) AddUser(user store.User, pwd string, ignoreIfExists bool) (string, error) {
	if mock.AddUserFunc == nil {
		panic("InterfaceMock.AddUserFunc: method is nil but Interface.AddUser was just called")
	}
	callInfo := struct {
		User           store.User
		Pwd            string
		IgnoreIfExists bool
	}{
		User:           user,
		Pwd:            pwd,
		IgnoreIfExists: ignoreIfExists,
	}
	mock.lockAddUser.Lock()
	mock.calls.AddUser = append(mock.calls.AddUser, callInfo)
	mock.lockAddUser.Unlock()
	return mock.AddUserFunc(user, pwd, ignoreIfExists)
}

// AddUserCalls gets all the calls that were made to AddUser.
// Check the length with:
//     len(mockedInterface.AddUserCalls())
func (mock *InterfaceMock) AddUserCalls() []struct {
	User           store.User
	Pwd            string
	IgnoreIfExists bool
} {
	var calls []struct {
		User           store.User
		Pwd            string
		IgnoreIfExists bool
	}
	mock.lockAddUser.RLock()
	calls = mock.calls.AddUser
	mock.lockAddUser.RUnlock()
	return calls
}

// GetPasswordHash calls GetPasswordHashFunc.
func (mock *InterfaceMock) GetPasswordHash(email string) (string, error) {
	if mock.GetPasswordHashFunc == nil {
		panic("InterfaceMock.GetPasswordHashFunc: method is nil but Interface.GetPasswordHash was just called")
	}
	callInfo := struct {
		Email string
	}{
		Email: email,
	}
	mock.lockGetPasswordHash.Lock()
	mock.calls.GetPasswordHash = append(mock.calls.GetPasswordHash, callInfo)
	mock.lockGetPasswordHash.Unlock()
	return mock.GetPasswordHashFunc(email)
}

// GetPasswordHashCalls gets all the calls that were made to GetPasswordHash.
// Check the length with:
//     len(mockedInterface.GetPasswordHashCalls())
func (mock *InterfaceMock) GetPasswordHashCalls() []struct {
	Email string
} {
	var calls []struct {
		Email string
	}
	mock.lockGetPasswordHash.RLock()
	calls = mock.calls.GetPasswordHash
	mock.lockGetPasswordHash.RUnlock()
	return calls
}

// GetUser calls GetUserFunc.
func (mock *InterfaceMock) GetUser(id string) (store.User, error) {
	if mock.GetUserFunc == nil {
		panic("InterfaceMock.GetUserFunc: method is nil but Interface.GetUser was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: id,
	}
	mock.lockGetUser.Lock()
	mock.calls.GetUser = append(mock.calls.GetUser, callInfo)
	mock.lockGetUser.Unlock()
	return mock.GetUserFunc(id)
}

// GetUserCalls gets all the calls that were made to GetUser.
// Check the length with:
//     len(mockedInterface.GetUserCalls())
func (mock *InterfaceMock) GetUserCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	mock.lockGetUser.RLock()
	calls = mock.calls.GetUser
	mock.lockGetUser.RUnlock()
	return calls
}
